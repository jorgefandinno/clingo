// {{{ MIT License

// Copyright 2017 Roland Kaminski

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

// }}}

#define YYCTYPE     char
#define YYCURSOR    cursor()
#define YYLIMIT     limit()
#define YYMARKER    marker()
#define YYFILL(n)   {fill(n);}
#define YYCTXMARKER ctxmarker()
#define YYGETCONDITION condition
#define YYSETCONDITION condition

// Note: THEORYOP is also used in output/backends.cc
/*!re2c
    re2c:cond:goto = "continue;";

    DEC        = "0"|([1-9][0-9]*);
    HEX        = "0x"([0-9A-Fa-f]+);
    OCT        = "0o"([1-7]+);
    BIN        = "0b"([0-1]+);
    NUMBER     = DEC | HEX | OCT | BIN;
    ANY        = [\000-\377];
    WS         = [\t\r ]*;
    NL         = "\n";
    IDENTIFIER = [_']*[a-z]['A-Za-z0-9_]*;
    VARIABLE   = [_']*[A-Z]['A-Za-z0-9_]*;
    ANONYMOUS  = "_";
    STRING     = "\"" ([^\\"\n]|"\\\""|"\\\\"|"\\n")* "\"";
    WSNL       = [\t\r\n ]*;
    SIG        = WSNL ([-$])? WSNL IDENTIFIER WSNL "/" WSNL NUMBER WSNL ".";
    SCRIPT     = "#script";
    THEORYOP0  = [/!<=>+\-*\\?&@|:;~\^\.];
    THEORYOP   = THEORYOP0+;
    THEORYOPL1 = [/!<=>+\-*\\?&@|;~\^\.];
    THEORYOPL2 = [/!<=>+\*\\?&@|:;~\^\.];
    THEORYOPL  = (THEORYOPL1 THEORYOP | ":" | ":" THEORYOPL2 THEORYOP0* | ":-" THEORYOP) WSNL "&";
    SUP        = "#sup"("remum")?;
    INF        = "#inf"("imum")?;
    KEYWORD    = "#" [a-zA-Z0-9_]*;
*/

int Gringo::Input::NonGroundParser::lex_impl(void *pValue, Location &loc) {
    int bc = 0;
    auto &value = *static_cast<Gringo::Input::NonGroundGrammar::parser::semantic_type*>(pValue);
    start(loc);
    for (;;) {
        /*!re2c
        <normal,maytheory,theory,definition,script> WS         { start(loc); continue; }
        <normal,maytheory,theory,definition,script> NL         { if(eof()) return 0; step(); start(loc); continue; }
        <normal,maytheory,theory> INF                          { return NonGroundGrammar::parser::token::INFIMUM; }
        <normal,maytheory,theory> SUP                          { return NonGroundGrammar::parser::token::SUPREMUM; }
        <normal,maytheory> SCRIPT                              => script { return NonGroundGrammar::parser::token::SCRIPT; }
        <normal,maytheory> "#include"                          { return NonGroundGrammar::parser::token::INCLUDE; }
        <normal,maytheory> "#edge"                             { return NonGroundGrammar::parser::token::EDGE; }
        <normal,maytheory> "#heuristic"                        { return NonGroundGrammar::parser::token::HEURISTIC; }
        <normal,maytheory> "#project"                          { return NonGroundGrammar::parser::token::PROJECT; }
        <normal,maytheory> "#show"                             { return NonGroundGrammar::parser::token::SHOW; }
        <normal,maytheory> "#show"/SIG                         { return NonGroundGrammar::parser::token::SHOWSIG; }
        <normal,maytheory> "#const"                            { return NonGroundGrammar::parser::token::CONST; }
        <normal,maytheory> "#minimi"[zs]"e"                    { return NonGroundGrammar::parser::token::MINIMIZE; }
        <normal,maytheory> "#maximi"[zs]"e"                    { return NonGroundGrammar::parser::token::MAXIMIZE; }
        <normal,maytheory> "#program"                          { return NonGroundGrammar::parser::token::BLOCK; }
        <normal,maytheory> "#external"                         { return NonGroundGrammar::parser::token::EXTERNAL; }
        <normal,maytheory> "#defined"                          { return NonGroundGrammar::parser::token::DEFINED; }
        <definition> "left"                          { return NonGroundGrammar::parser::token::LEFT; }
        <definition> "right"                         { return NonGroundGrammar::parser::token::RIGHT; }
        <definition> "head"                          { return NonGroundGrammar::parser::token::HEAD; }
        <definition> "body"                          { return NonGroundGrammar::parser::token::BODY; }
        <definition> "any"                           { return NonGroundGrammar::parser::token::ANY; }
        <definition> "binary"                        { return NonGroundGrammar::parser::token::BINARY; }
        <definition> "unary"                         { return NonGroundGrammar::parser::token::UNARY; }
        <definition> "directive"                     { return NonGroundGrammar::parser::token::DIRECTIVE; }

        <normal,maytheory,theory> "not"                        { value.str = String::toRep(not_); return NonGroundGrammar::parser::token::NOT; }
        <normal,maytheory> "default"                           { value.str = String::toRep(string()); return NonGroundGrammar::parser::token::DEFAULT; }
        <normal,maytheory> "override"                          { value.str = String::toRep(string()); return NonGroundGrammar::parser::token::OVERRIDE; }
        <normal,maytheory> ANONYMOUS                           { return NonGroundGrammar::parser::token::ANONYMOUS; }
        <normal,maytheory,theory,definition,script> IDENTIFIER { value.str = String::toRep(string()); return NonGroundGrammar::parser::token::IDENTIFIER; }
        <normal,maytheory,theory,definition> NUMBER            { value.num = integer(); return NonGroundGrammar::parser::token::NUMBER; }
        <normal,maytheory,theory> VARIABLE                     { value.str = String::toRep(string()); return NonGroundGrammar::parser::token::VARIABLE; }
        <normal,maytheory,theory> STRING                       { value.str = String::toRep(unquote(string(1, 1)).c_str()); return NonGroundGrammar::parser::token::STRING; }

        <normal,maytheory> "#true"                             { return NonGroundGrammar::parser::token::TRUE; }
        <normal,maytheory> "#false"                            { return NonGroundGrammar::parser::token::FALSE; }
        <normal,maytheory> "#sum"                              { return NonGroundGrammar::parser::token::SUM; }
        <normal,maytheory> "#sum+"                             { return NonGroundGrammar::parser::token::SUMP; }
        <normal,maytheory> "#count"                            { return NonGroundGrammar::parser::token::COUNT; }
        <normal,maytheory> "#min"                              { return NonGroundGrammar::parser::token::MIN; }
        <normal,maytheory> "#max"                              { return NonGroundGrammar::parser::token::MAX; }
        <normal,maytheory> "#disjoint"                         { return NonGroundGrammar::parser::token::DISJOINT; }
        <normal,maytheory> "#theory"                           { return NonGroundGrammar::parser::token::THEORY; }
        <normal,maytheory,theory,definition> ";"               { return NonGroundGrammar::parser::token::SEM; }
        <normal,maytheory> ".."                                { return NonGroundGrammar::parser::token::DOTS; }
        <normal,maytheory,theory,definition> "."               { return NonGroundGrammar::parser::token::DOT; }
        <normal,maytheory,theory,definition> ":"               { return NonGroundGrammar::parser::token::COLON; }
        <normal,maytheory,theory> ":-"                         { return NonGroundGrammar::parser::token::IF; }
        <normal,maytheory> ":~"                                { return NonGroundGrammar::parser::token::WIF; }
        <normal,maytheory,theory,definition> ","               { return NonGroundGrammar::parser::token::COMMA; }
        <normal,maytheory> "|"                                 { return NonGroundGrammar::parser::token::VBAR; }
        <normal,maytheory,theory> "["                          { return NonGroundGrammar::parser::token::LBRACK; }
        <normal,maytheory,theory> "]"                          { return NonGroundGrammar::parser::token::RBRACK; }
        <normal,maytheory,theory,script> "("                   { return NonGroundGrammar::parser::token::LPAREN; }
        <normal,maytheory,theory> ")"                          { return NonGroundGrammar::parser::token::RPAREN; }
        <script> ")" WS                              => script_body { start(loc); return NonGroundGrammar::parser::token::RPAREN; }
        <normal,maytheory,theory,definition> "{"               { return NonGroundGrammar::parser::token::LBRACE; }
        <normal,maytheory,theory,definition> "}"               { return NonGroundGrammar::parser::token::RBRACE; }
        <normal,maytheory> "+"                                 { return NonGroundGrammar::parser::token::ADD; }
        <normal,maytheory> "-"                                 { return NonGroundGrammar::parser::token::SUB; }
        <normal,maytheory> "**"                                { return NonGroundGrammar::parser::token::POW; }
        <normal,maytheory> "\\"                                { return NonGroundGrammar::parser::token::MOD; }
        <normal,maytheory> "*"                                 { return NonGroundGrammar::parser::token::MUL; }
        <normal,maytheory> ">"                                 { return NonGroundGrammar::parser::token::GT; }
        <normal,maytheory> "<"                                 { return NonGroundGrammar::parser::token::LT; }
        <normal,maytheory> ">="                                { return NonGroundGrammar::parser::token::GEQ; }
        <normal,maytheory> "<="                                { return NonGroundGrammar::parser::token::LEQ; }
        <normal,maytheory> "=="                                { return NonGroundGrammar::parser::token::EQ; }
        <normal,maytheory> "!="                                { return NonGroundGrammar::parser::token::NEQ; }
        <normal,maytheory> "<>"                                { return NonGroundGrammar::parser::token::NEQ; }
        <normal,maytheory> "="                                 { return NonGroundGrammar::parser::token::EQ; }
        <normal,maytheory,definition> "/"                      { return NonGroundGrammar::parser::token::SLASH; }
        <normal,maytheory> "@"                                 { return NonGroundGrammar::parser::token::AT; }
        <normal,maytheory,definition> "&"                      { return NonGroundGrammar::parser::token::AND; }
        <normal,maytheory> "^"                                 { return NonGroundGrammar::parser::token::XOR; }
        <normal,maytheory> "~"                                 { return NonGroundGrammar::parser::token::BNOT; }
        <normal,maytheory> "?"                                 { return NonGroundGrammar::parser::token::QUESTION; }
        <normal,maytheory> "$"                                 { return NonGroundGrammar::parser::token::CSP; }
        <normal,maytheory> "$+"                                { return NonGroundGrammar::parser::token::CSP_ADD; }
        <normal,maytheory> "$-"                                { return NonGroundGrammar::parser::token::CSP_SUB; }
        <normal,maytheory> "$*"                                { return NonGroundGrammar::parser::token::CSP_MUL; }
        <normal,maytheory> "$<="                               { return NonGroundGrammar::parser::token::CSP_LEQ; }
        <normal,maytheory> "$<"                                { return NonGroundGrammar::parser::token::CSP_LT; }
        <normal,maytheory> "$>="                               { return NonGroundGrammar::parser::token::CSP_GEQ; }
        <normal,maytheory> "$>"                                { return NonGroundGrammar::parser::token::CSP_GT; }
        <normal,maytheory> "$=="                               { return NonGroundGrammar::parser::token::CSP_EQ; }
        <normal,maytheory> "$="                                { return NonGroundGrammar::parser::token::CSP_EQ; }
        <normal,maytheory> "$!="                               { return NonGroundGrammar::parser::token::CSP_NEQ; }
        <normal,maytheory> "$<>"                               { return NonGroundGrammar::parser::token::CSP_NEQ; }
        <theory> THEORYOP                                      { value.str = String::toRep(string()); return NonGroundGrammar::parser::token::THEORY_OP; }
        <maytheory> THEORYOPL                           { value.str = String::toRep(string()); return NonGroundGrammar::parser::token::THEORY_OPL; }
        <normal,maytheory,theory,definition,script> "%*"       => blockcomment { bc++; continue; }
        <normal,maytheory,theory,definition,script> "%"        :=> comment
        <normal,maytheory,theory,definition,script> "#!"       :=> comment
        <normal,maytheory,theory,definition,script> KEYWORD    { lexerError(end(loc), string()); continue; }
        <normal,maytheory,theory,definition,script> ANY        { lexerError(end(loc), string()); continue; }

        <script_body> WS "#end" => normal {
            auto span = string();
            size_t size = span.size - 4;
            for (; size > 0; --size) {
                char c = span[size - 1];
                if (c != ' ' && c != '\t' && c != '\r') {
                    break;
                }
            }
            std::string s(span.first, span.first + size);
            value.str = String::toRep(s.c_str());
            return NonGroundGrammar::parser::token::CODE;
        }
        <script_body> NL {
            if(eof()) {
                lexerError(eof(loc), Potassco::toSpan("<EOF>", 5));
                return 0;
            }
            step();
            continue;
        }
        <script_body> ANY { continue; }

        <blockcomment> "*%" { if(--bc == 0) { condition(yycnormal); start(loc); } continue; }
        <blockcomment> "%*" { bc++; continue; }
        <blockcomment> "%"  :=> comment
        <blockcomment> NL   { if(eof()) { lexerError(eof(loc), Potassco::toSpan("<EOF>", 5)); return 0; } step(); continue; }
        <blockcomment> ANY  { continue; }

        <comment> NL {
            if(eof()) {
                if(bc > 0) { lexerError(eof(loc), Potassco::toSpan("<EOF>", 5)); }
                return 0;
            }
            step();
            if (bc > 0) { condition(yycblockcomment); }
            else {
                condition(yycnormal);
                start(loc);
            }
            continue;
        }
        <comment> ANY { continue; }
        */
    }
    assert(false);
    return 0;
}

#undef YYCTYPE
#undef YYCURSOR
#undef YYLIMIT
#undef YYMARKER
#undef YYFILL
#undef YYCTXMARKER
#undef YYGETCONDITION
#undef YYSETCONDITION
